package jira

import (
	"fmt"
	"log"
	"path/filepath"
	"strconv"

	"github.com/andygrunwald/go-jira"
	"github.com/trivago/tgo/tcontainer"

	"consumers/jira_c/config"
)

type defaultJiraFields struct {
	Project         jira.Project
	IssueType       jira.IssueType
	Components      []*jira.Component
	AffectsVersions []*jira.AffectsVersion
	Labels          []string
	CustomFields    tcontainer.MarshalMap
}

// getDefaultFields creates the fields for Project, IssueType, Components, AffectsVersions, Labels and CustomFields
// with the default values specified in config.yaml and serializes them into Jira Fields
func getDefaultFields(config config.Config) defaultJiraFields {
	defaultFields := defaultJiraFields{}
	defaultFields.Project = jira.Project{
		Key: config.DefaultValues.Project,
	}

	defaultFields.IssueType = jira.IssueType{
		Name: config.DefaultValues.IssueType,
	}

	components := []*jira.Component{}
	for _, v := range config.DefaultValues.Components {
		components = append(components, &jira.Component{Name: v})
	}
	defaultFields.Components = components

	affectsVersions := []*jira.AffectsVersion{}
	for _, v := range config.DefaultValues.AffectsVersions {
		affectsVersions = append(affectsVersions, &jira.AffectsVersion{Name: v})
	}
	defaultFields.AffectsVersions = affectsVersions

	defaultFields.Labels = config.DefaultValues.Labels

	customFields := tcontainer.NewMarshalMap()
	for _, cf := range config.DefaultValues.CustomFields {
		customFields[cf.ID] = makeCustomField(cf.FieldType, cf.Values)
	}
	defaultFields.CustomFields = customFields

	return defaultFields
}

// makeCustomField returns the appropriate interface for a jira CustomField given it's type and values
// :param fieldType: the type of the field in Jira (single-value, multi-value, float)
// :param values: list of values to be filled in
// :return the appropriate interface for a CustomField, given the corresponding fieldType and value(s)
func makeCustomField(fieldType string, values []string) interface{} {
	switch fieldType {
	case "single-value":
		return map[string]string{"value": values[0]}
	case "multi-value":
		cf := []map[string]string{}
		for _, v := range values {
			cf = append(cf, map[string]string{"value": v})
		}
		return cf
	case "float":
		if f, err := strconv.ParseFloat(values[0], 64); err == nil {
			return f
		} else {
			log.Fatalf("Error parsing float field-type: %v", err)
		}
	default:
		log.Printf("Warning: Field type %s is not supported. Edit your config.yaml file, as this field will not be displayed correctly.", fieldType)
		return nil
	}
	return nil
}

// makeDescription creates the description of an issue's enhanced with extra information from the Dracon Result
// depending on the tool used, diffrent fields are more suitable as description
// TODO: Make changes to the producers so that they automatically use the appropriate fields for description
func makeDescription(draconResult map[string]string, extras []string) string {
	desc := "This issue was automatically generated by the Dracon security pipeline.\n\n"
	switch draconResult["tool_name"] {
	case "gosec":
		desc = desc + "*" + draconResult["title"] + "*" + "\n\n"
	case "spotbugs":
		desc = desc + "*" + draconResult["description"] + "*" + "\n\n"
	case "bandit":
		desc = desc + "*" + draconResult["description"] + "*" + "\n\n"
	}

	// Append the extra fields to the description
	if len(extras) > 0 {
		desc = desc + "{code:}" + "\n"
		for _, s := range extras {
			desc = desc + fmt.Sprintf("%s: %*s\n", s, 25-len(s)+len(draconResult[s]), draconResult[s])
		}
		desc = desc + "{code}" + "\n"
	}
	return desc
}

// makeSummary creates the Summary/Title of an issue
// depending on the tool used, different fields are more suitable as summary
// TODO: Make changes to the producers so that they automatically use the appropriate fields for summary/title
func makeSummary(draconResult map[string]string) string {
	switch draconResult["tool_name"] {
	case "gosec":
		return filepath.Base(draconResult["target"]) + " " + draconResult["description"]
	case "spotbugs":
		return filepath.Base(draconResult["target"]) + " " + draconResult["title"]
	case "bandit":
		// Note: setting character limit to 100 until the bandit producer's 'title' gets fixed
		return fmt.Sprintf("%.120s", (filepath.Base(draconResult["target"]) + " " + draconResult["description"]))
		// Replace the line with this once PR#47 gets merged
		// return filepath.Base(draconResult["target"]) + " " + draconResult["title"]
	}
	return ""
}
